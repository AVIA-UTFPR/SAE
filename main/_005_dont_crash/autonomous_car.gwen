GWENDOLEN

:name: Car001

:Initial Beliefs:

min(0,0)


:Reasoning Rules:

arrived(X,Y) :- destination(X,Y), at(X,Y);
drive_to(X,Y) :- arrived(X,Y);
finish_all_rides :- done_all_rides;

position_grid(AT_X, AT_Y, D_X, D_Y) :- at(AT_X, AT_Y), destination(D_X, D_Y);

// Route
turn(north, X, Y) :- heading(north), at(AT_X, Y);
turn(south, X, Y) :- heading(south), at(AT_X, Y);


// adapt Route
can_drive(DIR) :- at(AT_X, AT_Y), ~obstacle(DIR, AT_X, AT_Y), ~road_ends_at(DIR, AT_X, AT_Y), ~no_further(DIR, AT_X, AT_Y);

go(north_south)	:- ~heading(north), ~heading(south), ~adapt(east), ~adapt(west);
go(east_west) 	:- ~heading(east), ~heading(west), ~adapt(north), ~adapt(south);


go(north) :- ~adapt(south), go(north_south);
go(south) :- ~adapt(north), go(north_south);

go(east) :- ~adapt(west), go(east_west);
go(west) :- ~adapt(east), go(east_west);


// No Emergency in (X,Y)
control_emergency (X,Y) :- ~crashed(X,Y);

// Avoid obstacles
avoid_obstacle(D, X, Y) :- ~at(X,Y);
//adapt_route(D, X, Y) :- ~at(X,Y);

:Initial Goals:

finish_all_rides [achieve]

:Plans:

// Get location of the car in the environment
+!finish_all_rides [achieve] : {~B at(X,Y)} <- localize, *at(GPS_X, GPS_Y);

// If no passengers is available, car goes back to depot
+!finish_all_rides [achieve] : {B no_possible_new_ride, B depot(X,Y)} <- +!complete_journey (X, Y) [perform], park(depot), +done_all_rides;

// get new ride
+!finish_all_rides [achieve] : {~B ride_info} <- get_ride, *ride_info;


// Verify it can reach destinations of the new ride
+!finish_all_rides [achieve] : {B ride_info, B pick_up(X, Y),  ~B verify_journey(X,Y)} 
								<- +!verify_reach_destination (X,Y) [perform], +verify_journey(X,Y);

+!finish_all_rides [achieve] : {B ride_info, B pick_up(X, Y),  B verify_journey(X,Y), ~B possible_journey_to(X,Y)} 
								<- refuse_ride(pick_up), +!clear_current_ride [perform];
								
+!finish_all_rides [achieve] : {B ride_info, B drop_off(X, Y), ~B verify_journey(X,Y)} 
								<- +!verify_reach_destination (X,Y) [perform], +verify_journey(X,Y);

+!finish_all_rides [achieve] : {B ride_info, B drop_off(X, Y), B verify_journey(X,Y), ~B possible_journey_to(X,Y)} 
								<- refuse_ride(drop_off), +!clear_current_ride [perform];
	

// Current ride - Pick up
+!finish_all_rides [achieve] : {B ride_info, ~B try_pick_up(X,Y), B pick_up(X,Y), ~B passenger}
								<- +!complete_journey (X,Y) [perform], +try_pick_up(X,Y);	
+!finish_all_rides [achieve] : {B ride_info, B try_pick_up(X,Y), B at(X,Y), B pick_up(X,Y), ~B passenger}
								<- park(pick_up), +passenger, -pick_up(X,Y), -try_pick_up(X,Y);	
								
+!finish_all_rides [achieve] : {B ride_info, B try_pick_up(X,Y), ~B at(X, Y), B pick_up(X,Y), ~B passenger}
								<- refuse_ride(pick_up), -pick_up(X,Y), -try_pick_up(X,Y), -ride_info;	
								
								
// Current ride - Drop off		
+!finish_all_rides [achieve] : {B ride_info, ~B try_drop_off(X,Y), B drop_off(X,Y), B passenger}
								<- 	+!complete_journey (X,Y) [perform], +try_drop_off(X,Y);
+!finish_all_rides [achieve] : {B ride_info, B try_drop_off(X,Y), B at(X,Y), B drop_off(X,Y), B passenger}
								<- 	park(drop_off), -passenger, -drop_off(X,Y), -try_drop_off(X,Y), -ride_info;

+!finish_all_rides [achieve] : {B ride_info, B try_drop_off(X,Y), ~B at(X, Y), B drop_off(X,Y), B passenger}
								<- 	refuse_ride(drop_off), park(drop_off), -passenger, -drop_off(X,Y), -try_drop_off(X,Y), -ride_info;							
																	
																	
+!clear_current_ride [perform] : {True} <- -pick_up(PK_X,PK_Y), -drop_off(DP_X,DP_Y), -ride_info;

// Verify if can reach destination
+!verify_reach_destination (V_X,V_Y) [perform] : {B min(MIN_X, MIN_Y), V_X < MIN_X}  ;	//print("cant reach destination MIN X")
+!verify_reach_destination (V_X,V_Y) [perform] : {B min(MIN_X, MIN_Y), V_Y < MIN_Y}  ;	//print("cant reach destination MIN Y") 
+!verify_reach_destination (V_X,V_Y) [perform] : {B max(MAX_X, MAX_Y), MAX_X < V_X}  ;	//print("cant reach destination MAX X") 
+!verify_reach_destination (V_X,V_Y) [perform] : {B max(MAX_X, MAX_Y), MAX_Y < V_Y}  ;	//print("cant reach destination MAX Y") 

// if no previous GUARD matched, then the journey is possible 
+!verify_reach_destination (V_X,V_Y) [perform] : {True}  <- +possible_journey_to(V_X,V_Y);
									
+!complete_journey (X,Y) [perform] : {True} <- 	+!clear_travel_data [perform], 
												+destination(X,Y),
												+moving, +!drive_to(X, Y) [achieve], -moving, 
												-destination(X, Y);

+!clear_travel_data [perform] : {True} 
									<- 	+!clear_direction_data [perform],
										-heading(north), -heading(south), -heading(east), -heading(west),
										-adapt(north), -adapt(south),  -adapt(east), -adapt(west);
										
+!clear_direction_data [perform] : {True} <- -north, -south, -east, -west, -receive_direction;

+!get_route [perform] : {B destination(X,Y)} <- +!clear_travel_data [perform], compass(X, Y), *receive_direction;

// Choose first direction to go
+!drive_to(X,Y) [achieve] : {~B north, ~B south, ~B east, ~B west} <- +!get_route [perform];

// Decide where the car should head to
+!drive_to(X,Y) [achieve] : {~B heading(H), B north} <- +heading(north);
+!drive_to(X,Y) [achieve] : {~B heading(H), B south} <- +heading(south);
+!drive_to(X,Y) [achieve] : {~B heading(H), B east}  <- +heading(east);
+!drive_to(X,Y) [achieve] : {~B heading(H), B west}  <- +heading(west);

// If car needs to turn
+!drive_to(X,Y) [achieve] : {B turn(north, X, Y), B east}  <- -heading(north), +heading(east); // north to east
+!drive_to(X,Y) [achieve] : {B turn(north, X, Y), B west}  <- -heading(north), +heading(west); // north to west 

+!drive_to(X,Y) [achieve] : {B turn(south, X, Y), B east}  <- -heading(south), +heading(east); // south to east
+!drive_to(X,Y) [achieve] : {B turn(south, X, Y), B west}  <- -heading(south), +heading(west); // south to west 

+!drive_to(X,Y) [achieve] : {B heading(east), B east, B at(X, AT_Y), B north}  <- -heading(east), +heading(north); // east to north
+!drive_to(X,Y) [achieve] : {B heading(east), B east, B at(X, AT_Y), B south}  <- -heading(east), +heading(south); // east to south

+!drive_to(X,Y) [achieve] : {B heading(west), B west, B at(X, AT_Y), B north}  <- -heading(west), +heading(north); // west to north
+!drive_to(X,Y) [achieve] : {B heading(west), B west, B at(X, AT_Y), B south}  <- -heading(west), +heading(south); // west to south	


// If car is blocked, drop the goal
+!drive_to(X,Y) [achieve] : {B blocked} <- -blocked, -!drive_to(X,Y) [achieve];		

// Wait to be in movement to drive
+!drive_to(X,Y) [achieve] : {~B moving} <- *moving;		

// adapt Route because of dead ends						
//+!drive_to(X,Y) [achieve] : {B moving, B heading(D), B at(AT_X, AT_Y), 
//							~B obstacle(D, AT_X, AT_Y), B road_ends_at(D, AT_X, AT_Y), ~B road_ends_at(center, X, Y)} 
//							<- -moving, +!adapt_route(D, AT_X, AT_Y) [achieve];

// Obstacle Avoidance						
+!drive_to(X,Y) [achieve] : {B moving, B heading(D), B at(AT_X, AT_Y), B obstacle(D, AT_X, AT_Y)} 
							<- -moving, +!adapt_route(D, AT_X, AT_Y) [achieve];

// When the car believes it can just move
+!drive_to(X,Y) [achieve] : {B moving, B heading(D)} <- -moving, drive(D);


// Obstacle Avoidance and adapt Route	
+!adapt_route(D, X, Y) [achieve] : {B obstacle(north, X, Y), B obstacle(south, X, Y), B obstacle(east, X, Y), B obstacle(west, X, Y)} 
									  	<- +blocked, -!avoid_obstacle(D, X, Y) [achieve];

// adapt Route
+!adapt_route(D, X, Y) [achieve] : {B can_drive(D)} 
									<- 	-moving, print("Fixed Route"),
										-adapt(north, X, Y), -adapt(south, X, Y),  -adapt(east, X, Y), -adapt(west, X, Y),
										+!drive_and_check_route(D) [perform], -!adapt_route(D, X, Y) [achieve], -reroute(D, X, Y); 
										
// Simple Belief North or South to East or West
+!adapt_route(D, X, Y) [achieve] : {B can_drive(east), B east, B go(east)} <- message("Simple Belief NS to East"), +!adapt_drive(east) [perform]; 
+!adapt_route(D, X, Y) [achieve] : {B can_drive(west), B west, B go(west)} <- message("Simple Belief NS to West"), +!adapt_drive(west) [perform];
							
// Reroute North or South to East or West		 						
+!adapt_route(D, X, Y) [achieve] : {B can_drive(east), B go(east)} <- message("Reroute NS to East"), +!adapt_drive(east) [perform]; 
+!adapt_route(D, X, Y) [achieve] : {B can_drive(west), B go(west)} <- message("Reroute NS to West"), +!adapt_drive(west) [perform]; 

//Simple Belief East or West to North or South
+!adapt_route(D, X, Y) [achieve] : {B can_drive(north), B north, B go(north)} <- message("Simple Belief EW to North"), +!adapt_drive(north) [perform]; 
+!adapt_route(D, X, Y) [achieve] : {B can_drive(south), B south, B go(south)} <- message("Simple Belief EW to South"), +!adapt_drive(south) [perform]; 
									
//Reroute Belief East or West to North or South
+!adapt_route(D, X, Y) [achieve] : {B can_drive(north), B go(north)} <- message("Reroute EW to North"), +!adapt_drive(north) [perform]; 
+!adapt_route(D, X, Y) [achieve] : {B can_drive(south), B go(south)} <- message("Reroute EW to South"), +!adapt_drive(south) [perform]; 

//Reroute the reroute
+!adapt_route(D, X, Y) [achieve] : {~B can_drive(north), B adapt(north), B at(AT_X, AT_Y)} 
									<- message("Cant keep going north"), 
										-adapt(north), 
										no_further_info(D, AT_X, AT_Y), no_further_info(north, AT_X, AT_Y),
										-moving, drive(south); 
									
+!adapt_route(east, X, Y) [achieve] : {~B can_drive(north), ~B can_drive(south), ~B can_drive(east), B can_drive(west), B at(AT_X, AT_Y)} 
									<- message("Cant keep going east"), 
										no_further_info(east, AT_X, AT_Y),
										-moving, drive(west); 
										
+!adapt_route(west, X, Y) [achieve] : {~B can_drive(north), ~B can_drive(south), ~B can_drive(west), B can_drive(east), B at(AT_X, AT_Y)} 
									<- message("Cant keep going west"), 
										no_further_info(west, AT_X, AT_Y),
										-moving, drive(east); 
									
+!adapt_route(D, X, Y) [achieve] : {True} <- message(D), print("adapt_route_true"), +blocked, -!adapt_route(D, X, Y) [achieve];




+!adapt_drive(D) [perform] : {True} <- +adapt(D), -moving, drive(D);

+!drive_and_check_route(D) [perform] : {True} <- -moving, drive(D), *at(AT_X, AT_Y), +!get_route [perform];

//+no_further(D, X, Y) : {True} <- message(D), message(X), message(Y);
//-adapt(D, X, Y) : {True} <- message(D), message(X), message(Y);


+at(X,Y) : {B obstacle(center, X,Y)} <- -moving, +crashed(X,Y), +!control_emergency (X,Y) [achieve], +moving;
+at(X,Y) : {~B obstacle(center, X,Y)} <- +moving;


// If Crashed, ask for help
+!control_emergency (X,Y) [achieve] : {B help(X,Y), B alert_state} <-  -help(X,Y), -alert_state, -crashed(X,Y);
+!control_emergency (X,Y) [achieve] : {B crashed(X,Y), ~B alert_state} <- call_emergency(X,Y), *help(X,Y), +alert_state;
