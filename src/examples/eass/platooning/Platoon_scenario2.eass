<<<<<<< HEAD

/*
	Platooning Scenario 2

	A vehicle joins the platoon from behind, one vehicle RE + leader RE + simple joining protocol, Same for leaving platoon from behind. States to be monitored: joining-req, leaving-req

	A vehicle at the end of the platoon sends a join or leave request to the leader. In case of joining, the leader through a simple joining protocol decides to authorise the vehicle 
	to join and synchronise clocks. The vehicle receiving confirmation decides for itself to go through a series of switches in order to get to platoon control. 
	We will then verify if the vehicle gets a confirmation from the leader for joining then it switches to platoon control and if the vehicle doesn't get a confirmation from the leader
	for joining then it stays on cruise control.

	There are some temporal properties such as if in some certain amount of time the last vehicle gets to Ok-distance, meaning the joining protocol satisfies the joining requirement
	and when a vehicle leaves the platoon, we can check after e.g., 2 sec., the vehicle is too-far from the platoon. These remain for future work because at the moment we cannot 
	verify them in AJPF. We need to investigate on how to export models from AJPF to UPPAAL.

	Our assumption is that other vehicles do nothing. The focus is on coordination between the leader and a vehicle joining the platoon from behind.


	ASSUMPTION: while a car from behind is joining, no car can leave platoon
				last car has highest platoon_ID
				(Design Decision) I am sending messages through abstract engine; communication between agents is in abstraction engine level; two REs don't talk to each other directly
*/


EASS

//=================================== behind vehicle abstract engine ===============================================

:abstraction: follower3

:Initial Beliefs:
vehicle_id(3)
init_min_speed(10) // minimum initial speed to switch to speed control
init_max_dist(20) // maximum initial distance to switch to steering control
//min_azimuth(9) // minimum azimuth to leave the platoon
leave_distance(15) // minimum distance to be able to leave the platoon
leave_time(100)

:Initial Goals:

:Plans:

/* Default plans for handling messages */
+.received(:tell, B): {True} <- +B;   
+.received(:perform, G): {True} <- +!G [perform];
+.received(:achieve, G): {True} <- +!G [achieve];

//================= follower abstraction, provides the required conditions for joining and leaving a platoon for reasoning engine ===========


+precedingPID(PID): {~B preceding_vehicle_platoon_member, 0 < PID}<- assert_shared(preceding_vehicle_platoon_member); // assume ID = 0 when a vehicle is not a member of the platoon
+precedingPID(PID): {B preceding_vehicle_platoon_member, PID < 1}<- remove_shared(preceding_vehicle_platoon_member); 

+egoPID(PID): {B no_platoon_member, 0 < PID}<- remove_shared(no_platoon_member);
+egoPID(PID): {~B no_platoon_member, PID == 0}<- assert_shared(no_platoon_member);

+speed(X): {~B initial_speed, B init_min_speed(Y), Y < X}<- assert_shared(initial_speed); // if vehicle's speed is greater than minimum initial speed, we add "initial_speed" belief
+speed(X): {B initial_speed, B init_min_speed(Y), X < Y}<- remove_shared(initial_speed); // if vehicle's speed is less than minimum initial speed, we remove "initial_speed" belief

+distance(X): {B no_platoon_member, ~B initial_distance, B init_max_dist(Y), Y < X }<- assert_shared(initial_distance); // if vehicle's distance is less than maximum initial distance, we add "initial_distance" belief
+distance(X): {B no_platoon_member, B initial_distance, B init_max_dist(Y), X < Y }<- remove_shared(initial_distance); // if vehicle's distance is greater than maximum initial distance, we remove "initial_distance" belief

//+azimuth(X): {B ready_to_leave, ~B no_platoon_member, ~B azimuth, B min_azimuth(Y), Y < X }<- assert_shared(azimuth);
//+azimuth(X): {B ready_to_leave, ~B no_platoon_member, B azimuth, B min_azimuth(Y), X < Y }<- remove_shared(azimuth);

+distance(X): {~B no_platoon_member, B leave_distance(Y), Y < X }<- assert_shared(leave_distance);
+distance(X): {~B no_platoon_member, B leave_distance(Y), X < Y }<- remove_shared(leave_distance);

+timeStamp(X): {~B no_platoon_member, B leave_time(Y), Y < X}<- assert_shared(ready_to_leave); 

//+waiting_to_leave: {True}<-  print(wait_started), do_nothing, print(wait_over), remove_shared(waiting_to_leave), assert_shared(ready_to_leave);


//========== the list of actions that agent sends back to Simulator  ===============

+!speed_controller(X) [perform]: {True}<- run(pred(speed_controller),args(X));

+!steering_controller(X) [perform]: {True}<- run(pred(steering_controller),args(X));

+!assign_platoon_id(X) [perform]: {True}<- run(pred(assign_platoon_id),args(X));

+!set_spacing(Y) [perform]: {True}<- run(pred(set_spacing),args(Y));


//=================================== behind vehicle reasoning engine ===============================================

:name: follower3

:Initial Beliefs:

vehicle_id(3)
req(join)
req(leave)
leave_spacing(15)

:Reasoning Rules:

join_to_platoon_from_behind(X,Y):- preceding_vehicle_platoon_member, ~no_platoon_member;

leave_platoon_from_behind:- preceding_vehicle_platoon_member, no_platoon_member;

:Initial Goals:

:Plans:

/* Default plans for handling messages */
+.received(:tell, B): {True} <- +B;   
+.received(:perform, G): {True} <- +!G [perform];
+.received(:achieve, G): {True} <- +!G [achieve];


// ================================= joining to a platoon ================

// ================================= once the agent found out that is not part of platoon and the preceding vehicle is in platoon, it sends a request to leader to join ===============================
+no_platoon_member: {B preceding_vehicle_platoon_member, B vehicle_id(X), ~B request_to_join(X), B req(join), ~B leave_agreement(X)}<- .send(leader, :tell, message(X, 1)), +request_to_join(X), print(send_request_to_join);
+preceding_vehicle_platoon_member: {B no_platoon_member, B vehicle_id(X), ~B request_to_join(X), B req(join)}<- .send(leader, :tell, message(X, 1)), +request_to_join(X), print(send_request_to_join);

// ================================ when the follower recieves the agreement from leader for joining, it initiates a goal for joining ===========================================
+join_agreement(X,Y): {B no_platoon_member, B vehicle_id(X), B request_to_join(X) }<- -request_to_join(X), print(go_for_joining), +!join_to_platoon_from_behind(X,Y) [achieve];

// ================================ follower waits for speed>10  and distance>20, then enables speed controller ====================
+!join_to_platoon_from_behind(X,Y) [achieve]: {B preceding_vehicle_platoon_member, B no_platoon_member,
											B initial_speed, B initial_distance, B join_agreement(X,Y)}<- 
											perf(speed_controller(1)), +speed_controller,
											print(speed_controller_enabled);

// ================================ follower already enabled speed controller and its distance<20, then enables steering controller. ========================
// ================================ it also assigns the platoon ID which has been sent by leader. Finally sends a message to leader saying it is now a member of platoon  ====================				 
+!join_to_platoon_from_behind(X,Y) [achieve]: {B preceding_vehicle_platoon_member, B no_platoon_member,
											~B initial_distance, B join_agreement(X,Y), B speed_controller, B vehicle_id(Y)}<- 
											perf(assign_platoon_id(Y)), 
											perf(steering_controller(1)), 
											.send(leader, :tell, platoon_member(Y)),
											remove_shared(no_platoon_member),
											-join_agreement(X,Y),
											print(steering_controller_enabled),
											print(joining_to_platoon_completed);


// ================================ follower at first place informed that speed>10 and distance<20, then enables both speed and steering controllers.====================				 
// ================================ it also assigns the platoon ID which has been sent by leader. Finally sends a message to leader saying it is now a member of platoon  ====================				 
+!join_to_platoon_from_behind(X,Y) [achieve]: {B preceding_vehicle_platoon_member, B no_platoon_member,
											B initial_speed, ~B initial_distance, B join_agreement(X,Y), ~B speed_controller, B vehicle_id(Y)} <-
											perf(speed_controller(1)), +speed_controller,
											perf(assign_platoon_id(Y)),
											perf(steering_controller(1)), 
											.send(leader, :tell, platoon_member(Y)),
											remove_shared(no_platoon_member),
											-join_agreement(X,Y),
											print(speed_controller),
											print(steering_controller),
											print(joining_to_platoon_completed);


// ======================== leaving a platoon ==============================

// ======================== follower waits sometime after joining then initiates a goal for leaving the platoon ======================
+ready_to_leave: {True}<- print(leaving_can_start), +!leave_platoon_from_behind [achieve];

// ======================== follower sends a request to leader to leave and wait for reply =============================										
+!leave_platoon_from_behind [achieve]: {~B no_platoon_member, ~B request_to_leave(X), B vehicle_id(X)}<-
										print(send_request_to_leave), .send(leader, :tell, message(X, 0)),
										 +request_to_leave(X), *leave_agreement(X);

// ======================== when follower recieves agreement from the leader, first send command to set spacing = 20 and wait for the distance and azimuth data ======================											
+!leave_platoon_from_behind [achieve]: {~B no_platoon_member, B leave_agreement(X), B request_to_leave(X), B vehicle_id(X), B leave_spacing(Y), ~B set_spacing} <- 
										perf(set_spacing(Y)), *leave_distance, print(set_spacing_to_leave), +set_spacing; 

// ======================== when distance > 15 and azimuth >10, speed  and steering controllers being disable =============================
+!leave_platoon_from_behind [achieve]: {~B no_platoon_member, B leave_agreement(X), B request_to_leave(X), B vehicle_id(X),
										B set_spacing, B leave_distance,
										G leave_platoon_from_behind [achieve] }<-
										perf(speed_controller(0)), perf(steering_controller(0)), assert_shared(no_platoon_member), print(vehicle_left_platoon), remove_shared(ready_to_leave), -set_spacing; 


//=================================== leader abstract engine ===============================================


:abstraction: leader

:Initial Beliefs:

platoon_member(1) platoon_member(2) 
//platoon_member(3)
//platoon_member(4) platoon_member(5) platoon_member(6)
//platoon_member(7) platoon_member(8)
req(join)
req(leave)


:Initial Goals:

:Plans:

/* Default plans for handling messages */
+.received(:tell, B): {True} <- +B;   
+.received(:perform, G): {True} <- +!G [perform];
+.received(:achieve, G): {True} <- +!G [achieve];



//+!time_synch(SENDER) [perform]: {True}<- run(time_synchronisation); 

//=================================== leader reasoning engine ===============================================


:name: leader

:Initial Beliefs:

platoon_member(1) platoon_member(2) 
//platoon_member(3)
//platoon_member(4) platoon_member(5) platoon_member(6)
//platoon_member(7) platoon_member(8)
req(1) // means request to join
req(0) // means request to leave
last_car(2)

:Initial Goals:

:Plans:

/* Default plans for handling messages */
+.received(:tell, B): {True} <- +B;   
+.received(:perform, G): {True} <- +!G [perform];
+.received(:achieve, G): {True} <- +!G [achieve];

// =================================== leader receives a joining request ================
+message(SENDER, REQ): {~B platoon_member(SENDER), ~B request_to_join(SENDER), B req(1), 1 == REQ} <- 
						+request_to_join(SENDER),
						+accept_request_join(SENDER),
						print(leader_received_req); 

// =================================== leader receives a leaving request ================
+message(SENDER, REQ): {B platoon_member(SENDER), ~B request_to_leave(SENDER), B req(0), 0 == REQ} <-
						+request_to_leave(SENDER),
						+accept_request_leave(SENDER),
						print(leader_received_req_leave); 

// =================================== leader receives a confirmation from the last vehicle saying the follower is now part of the platoon ================
+platoon_member(SENDER): {~B request_to_join(SENDER), B last_car(X), X< SENDER}<- -accept_request_join(SENDER), -last_car(X), +last_car(SENDER), print(leader_knows_a_vehicle_joined_to_platoon);

// =================================== leader checks the sender if senderID is greater than the last vehicle in the platoon, it accepts the request and sends back the agreement to the follower to join (it is done in agent level)=========================
+accept_request_join(SENDER): {~B platoon_member(SENDER), B last_car(Y), Y < SENDER, ~B ack_sent(SENDER), B request_to_join(SENDER)} <- 
									.send(follower3, :tell, join_agreement(SENDER,SENDER)), -request_to_join(SENDER), //perf(time_synch(SENDER)),
									print(leader_sent_acknowledge_back_to_sender_to_join), -message(SENDER, 1);

// =================================== leader checks the sender if senderID is the last vehicle in the platoon, it accepts the request and sends back the agreement to the follower to leave (it is done in agent level)=========================
+accept_request_leave(SENDER): {B platoon_member(SENDER), B last_car(SENDER), ~B ack_sent_leave(SENDER), B request_to_leave(SENDER)} <- 
									.send(follower3, :tell, leave_agreement(SENDER)), -request_to_leave(SENDER),
									print(leader_sent_acknowledge_back_to_sender_to_leave), -message(SENDER, 0);
=======

/*
	Platooning Scenario 2

	A vehicle joins the platoon from behind, one vehicle RE + leader RE + simple joining protocol, Same for leaving platoon from behind. States to be monitored: joining-req, leaving-req

	A vehicle at the end of the platoon sends a join or leave request to the leader. In case of joining, the leader through a simple joining protocol decides to authorise the vehicle 
	to join and synchronise clocks. The vehicle receiving confirmation decides for itself to go through a series of switches in order to get to platoon control. 
	We will then verify if the vehicle gets a confirmation from the leader for joining then it switches to platoon control and if the vehicle doesn't get a confirmation from the leader
	for joining then it stays on cruise control.

	There are some temporal properties such as if in some certain amount of time the last vehicle gets to Ok-distance, meaning the joining protocol satisfies the joining requirement
	and when a vehicle leaves the platoon, we can check after e.g., 2 sec., the vehicle is too-far from the platoon. These remain for future work because at the moment we cannot 
	verify them in AJPF. We need to investigate on how to export models from AJPF to UPPAAL.

	Our assumption is that other vehicles do nothing. The focus is on coordination between the leader and a vehicle joining the platoon from behind.


	ASSUMPTION: while a car from behind is joining, no car can leave platoon
				last car has highest platoon_ID
				(Design Decision) I am sending messages through abstract engine; communication between agents is in abstraction engine level; two REs don't talk to each other directly
*/


EASS

//=================================== behind vehicle abstract engine ===============================================

:abstraction: follower3

:Initial Beliefs:
vehicle_id(3)
init_min_speed(10) // minimum initial speed to switch to speed control
init_max_dist(20) // maximum initial distance to switch to steering control
leave_distance(15) // minimum distance to be able to leave the platoon


:Initial Goals:

:Plans:

/* Default plans for handling messages */
+.received(:tell, B): {True} <- +B;   
+.received(:perform, G): {True} <- +!G [perform];
+.received(:achieve, G): {True} <- +!G [achieve];

//================= follower abstraction, provides the required conditions for joining and leaving a platoon for reasoning engine ===========


+precedingPID(PID): {~B preceding_vehicle_platoon_member, 0 < PID}<- assert_shared(preceding_vehicle_platoon_member); // assume ID = 0 when a vehicle is not a member of the platoon
+precedingPID(PID): {B preceding_vehicle_platoon_member, PID < 1}<- remove_shared(preceding_vehicle_platoon_member); 

+egoPID(PID): {B no_platoon_member, 0 < PID}<- remove_shared(no_platoon_member);
+egoPID(PID): {~B no_platoon_member, PID == 0}<- assert_shared(no_platoon_member);

+speed(X): {~B initial_speed, B init_min_speed(Y), Y < X}<- assert_shared(initial_speed); // if vehicle's speed is greater than minimum initial speed, we add "initial_speed" belief
+speed(X): {B initial_speed, B init_min_speed(Y), X < Y}<- remove_shared(initial_speed); // if vehicle's speed is less than minimum initial speed, we remove "initial_speed" belief

+distance(X): {~B ready_to_leave, ~B initial_distance, B init_max_dist(Y), Y < X }<- assert_shared(initial_distance); // if vehicle's distance is less than maximum initial distance, we add "initial_distance" belief
+distance(X): {~B ready_to_leave, B initial_distance, B init_max_dist(Y), X < Y }<- remove_shared(initial_distance); // if vehicle's distance is greater than maximum initial distance, we remove "initial_distance" belief

+distance(X): {B ready_to_leave, ~B no_platoon_member, B leave_distance(Y), Y < X }<- assert_shared(leave_distance);
+distance(X): {B ready_to_leave, ~B no_platoon_member, B leave_distance(Y), X < Y }<- remove_shared(leave_distance);


+waiting_to_leave: {True}<-  print(wait_started), do_nothing, print(wait_over), remove_shared(waiting_to_leave), assert_shared(ready_to_leave);



+! wait [perform] : {True} <-
	print(wait_started),
	wait(100000),
	*waited,
	print(wait_over),
	-waited;



//========== the list of actions that agent sends back to Simulator  ===============

+!speed_controller(X) [perform]: {True}<- run(pred(speed_controller),args(X));

+!steering_controller(X) [perform]: {True}<- run(pred(steering_controller),args(X));

+!assign_platoon_id(X) [perform]: {True}<- run(pred(assign_platoon_id),args(X));

+!set_spacing(Y) [perform]: {True}<- run(pred(set_spacing),args(Y));


//=================================== behind vehicle reasoning engine ===============================================

:name: follower3

:Initial Beliefs:

vehicle_id(3)
req(join)
req(leave)
leave_spacing(15)

:Reasoning Rules:

join_to_platoon_from_behind(X,Y):- preceding_vehicle_platoon_member, ~no_platoon_member;

leave_platoon_from_behind:- preceding_vehicle_platoon_member, no_platoon_member;

:Initial Goals:

:Plans:

/* Default plans for handling messages */
+.received(:tell, B): {True} <- +B;   
+.received(:perform, G): {True} <- +!G [perform];
+.received(:achieve, G): {True} <- +!G [achieve];


// ================================= joining to a platoon ================

// ================================= once the agent found out that is not part of platoon and the preceding vehicle is in platoon, it sends a request to leader to join ===============================
+no_platoon_member: {B preceding_vehicle_platoon_member, B vehicle_id(X), ~B request_to_join(X), B req(join), ~B leave_agreement(X)}<- .send(leader, :tell, message(X, 1)), +request_to_join(X), print(send_request_to_join);
+preceding_vehicle_platoon_member: {B no_platoon_member, B vehicle_id(X), ~B request_to_join(X), B req(join)}<- .send(leader, :tell, message(X, 1)), +request_to_join(X), print(send_request_to_join);

// ================================ when the follower recieves the agreement from leader for joining, it initiates a goal for joining ===========================================
+join_agreement(X,Y): {B no_platoon_member, B vehicle_id(X), B request_to_join(X) }<- -request_to_join(X), print(go_for_joining), +!join_to_platoon_from_behind(X,Y) [achieve];

// ================================ follower waits for speed>10  and distance>20, then enables speed controller ====================
+!join_to_platoon_from_behind(X,Y) [achieve]: {B preceding_vehicle_platoon_member, B no_platoon_member,
											B initial_speed, B initial_distance, B join_agreement(X,Y)}<- 
											perf(speed_controller(1)), +speed_controller,
											print(speed_controller_enabled);

// ================================ follower already enabled speed controller and its distance<20, then enables steering controller. ========================
// ================================ it also assigns the platoon ID which has been sent by leader. Finally sends a message to leader saying it is now a member of platoon  ====================				 
+!join_to_platoon_from_behind(X,Y) [achieve]: {B preceding_vehicle_platoon_member, B no_platoon_member,
											~B initial_distance, B join_agreement(X,Y), B speed_controller, B vehicle_id(Y)}<- 
											perf(assign_platoon_id(Y)), 
											perf(steering_controller(1)), 
											.send(leader, :tell, platoon_member(Y)),
											remove_shared(no_platoon_member),
											-join_agreement(X,Y),
											print(steering_controller_enabled),
											print(joining_to_platoon_completed), assert_shared(waiting_to_leave);


// ================================ follower at first place informed that speed>10 and distance<20, then enables both speed and steering controllers.====================				 
// ================================ it also assigns the platoon ID which has been sent by leader. Finally sends a message to leader saying it is now a member of platoon  ====================				 
+!join_to_platoon_from_behind(X,Y) [achieve]: {B preceding_vehicle_platoon_member, B no_platoon_member,
											B initial_speed, ~B initial_distance, B join_agreement(X,Y), ~B speed_controller, B vehicle_id(Y)} <-
											perf(speed_controller(1)), +speed_controller,
											perf(assign_platoon_id(Y)),
											perf(steering_controller(1)), 
											.send(leader, :tell, platoon_member(Y)),
											remove_shared(no_platoon_member),
											-join_agreement(X,Y),
											print(speed_controller),
											print(steering_controller),
											print(joining_to_platoon_completed), assert_shared(waiting_to_leave);


// ======================== leaving a platoon ==============================

// ======================== follower waits sometime after joining then initiates a goal for leaving the platoon ======================
+ready_to_leave: {True}<- print(leaving_can_start), +!leave_platoon_from_behind [achieve];

// ======================== follower sends a request to leader to leave and wait for reply =============================										
+!leave_platoon_from_behind [achieve]: {~B no_platoon_member, ~B request_to_leave(X), B vehicle_id(X)}<-
										print(send_request_to_leave), .send(leader, :tell, message(X, 0)),
										 +request_to_leave(X), *leave_agreement(X);

// ======================== when follower recieves agreement from the leader, first send command to set spacing = 20 and wait for the distance data ======================											
+!leave_platoon_from_behind [achieve]: {~B no_platoon_member, B leave_agreement(X), B request_to_leave(X), B vehicle_id(X), B leave_spacing(Y), ~B set_spacing} <- 
										perf(set_spacing(Y)), *leave_distance, print(set_spacing_to_leave), +set_spacing; 

// ======================== when distance > 15, speed  and steering controllers being disable =============================
+!leave_platoon_from_behind [achieve]: {B leave_agreement(X), B request_to_leave(X), B vehicle_id(X),
										B set_spacing, B leave_distance,
										G leave_platoon_from_behind [achieve] }<-
										perf(speed_controller(0)), perf(steering_controller(0)), assert_shared(no_platoon_member), print(vehicle_left_platoon), remove_shared(ready_to_leave), -set_spacing; 


//=================================== leader abstract engine ===============================================


:abstraction: leader

:Initial Beliefs:

platoon_member(1) platoon_member(2) 
//platoon_member(3)
//platoon_member(4) platoon_member(5) platoon_member(6)
//platoon_member(7) platoon_member(8)
req(join)
req(leave)


:Initial Goals:

:Plans:

/* Default plans for handling messages */
+.received(:tell, B): {True} <- +B;   
+.received(:perform, G): {True} <- +!G [perform];
+.received(:achieve, G): {True} <- +!G [achieve];



//+!time_synch(SENDER) [perform]: {True}<- run(time_synchronisation); 

//=================================== leader reasoning engine ===============================================


:name: leader

:Initial Beliefs:

platoon_member(1) platoon_member(2) 
//platoon_member(3)
//platoon_member(4) platoon_member(5) platoon_member(6)
//platoon_member(7) platoon_member(8)
req(1) // means request to join
req(0) // means request to leave
last_car(2)

:Initial Goals:

:Plans:

/* Default plans for handling messages */
+.received(:tell, B): {True} <- +B;   
+.received(:perform, G): {True} <- +!G [perform];
+.received(:achieve, G): {True} <- +!G [achieve];

// =================================== leader receives a joining request ================
+message(SENDER, REQ): {~B platoon_member(SENDER), ~B request_to_join(SENDER), B req(1), 1 == REQ} <- 
						+request_to_join(SENDER),
						+accept_request_join(SENDER),
						print(leader_received_req); 

// =================================== leader receives a leaving request ================
+message(SENDER, REQ): {B platoon_member(SENDER), ~B request_to_leave(SENDER), B req(0), 0 == REQ} <-
						+request_to_leave(SENDER),
						+accept_request_leave(SENDER),
						print(leader_received_req_leave); 

// =================================== leader receives a confirmation from the last vehicle saying the follower is now part of the platoon ================
+platoon_member(SENDER): {~B request_to_join(SENDER), B last_car(X), X< SENDER}<- -accept_request_join(SENDER), -last_car(X), +last_car(SENDER), print(leader_knows_a_vehicle_joined_to_platoon);

// =================================== leader checks the sender if senderID is greater than the last vehicle in the platoon, it accepts the request and sends back the agreement to the follower to join (it is done in agent level)=========================
+accept_request_join(SENDER): {~B platoon_member(SENDER), B last_car(Y), Y < SENDER, ~B ack_sent(SENDER), B request_to_join(SENDER)} <- 
									.send(follower3, :tell, join_agreement(SENDER,SENDER)), -request_to_join(SENDER), //perf(time_synch(SENDER)),
									print(leader_sent_acknowledge_back_to_sender_to_join), -message(SENDER, 1);

// =================================== leader checks the sender if senderID is the last vehicle in the platoon, it accepts the request and sends back the agreement to the follower to leave (it is done in agent level)=========================
+accept_request_leave(SENDER): {B platoon_member(SENDER), B last_car(SENDER), ~B ack_sent_leave(SENDER), B request_to_leave(SENDER)} <- 
									.send(follower3, :tell, leave_agreement(SENDER)), -request_to_leave(SENDER),
									print(leader_sent_acknowledge_back_to_sender_to_leave), -message(SENDER, 0);
>>>>>>> 58a05446252813df882c6215accac958acf2a325
									