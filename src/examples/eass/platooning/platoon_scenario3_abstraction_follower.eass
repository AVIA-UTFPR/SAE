
/*
	Platooning Scenario 3 FOLLOWER AGENT

	Recoverable latency problems. All vehicles have REs + leader RE. vehicles adapt spacing parameters based on latency problems
	An example of recoverable latency problem: if the difference between the time stamp on a message and the vehicle's clock is too great then the spacing should be double.
	In this scenario, we are interested to know what is the platoon tolerance to latency. How far we can get the platoon together. 
	How far can vehicles be from each other in order to still keep platoon. REs in vehicles independently decide about changing their spacing parameters and RE in leader decides 
	how spacing parameter can grow. For instance, if two vehicles are too-far, then the leader should not allow more increase of space between those two vehicles otherwise the platoon 
	breaks to parts that is described in Scenario 4.  

	For recoverable latency problem, we can verify that too-far state (defined for this particular control strategy) is not reachable.


	Assumption: all vehicles are members of platoon at the beginning

*/


:abstraction: follower

:Initial Beliefs:

next_latency(0,1)
next_latency(1,2)
next_latency(2,3)
next_latency(3,4)

spacing(0,50)
spacing(1,10)
spacing(2,15)
spacing(3,20)

check_latency_time(40)

:Initial Goals:

:Plans:

+.received(:tell, B): {True} <- +B;
+.received(:perform, G): {True} <- +!G [perform];


//+precedingPID(PID): {~B preceding_vehicle_platoon_member, 0 < PID}<- assert_shared(preceding_vehicle_platoon_member); // assume ID = 0 when a vehicle is not a member of the platoon
//+precedingPID(PID): {B preceding_vehicle_platoon_member, PID < 1}<- remove_shared(preceding_vehicle_platoon_member); 

+timeStamp(X): {~B check_latency, B check_latency_time(Y), Y < X}<- assert_shared(check_latency), print(checkLatencyStarted);

// if a vehicle recieves precedingPID from socket, we read precedingPID(X) (AT THE MOMEMENT IT IS NOT THE CASE)
// otherwise another piece of information should be considered like precedingSpeed(X) in order to detect latency
//+precedingPID(X): {B check_latency, ~ B latency(Y), X == 0 , ~B unrecoverable}<- assert_shared(latency(1)), print(latency1);
//+precedingPID(X): {B check_latency, ~ B latency(Y), 0 < X, ~B unrecoverable}<- assert_shared(latency(0)), print(latency0);

//+precedingPID(X): {B check_latency, B latency(Y), X == 0, B next_latency(Y,Z)}<- remove_shared(latency(Y)), assert_shared(latency(Z)),  print(Z);
//+precedingPID(X): {B check_latency, B latency(Y), X == 0, ~B next_latency(Y,Z)}<- remove_shared(latency(Y)), assert_shared(unrecoverable), print(unrecoverable);

//+precedingPID(X): {B check_latency, B latency(Y), 0 < Y, 0 < X, ~B unrecoverable}<- remove_shared(latency(Y)), assert_shared(latency(0)), print(latency0);


// (ALTERNATIVE OPTION) to detect latency, we need to consider some information which is transfered via communication links like "speed"
+precedingSpeed(X): {B check_latency, ~ B latency(Y), X == 0 , ~B unrecoverable}<- assert_shared(latency(1)), print(SpeedReadinglatency1);
+precedingSpeed(X): {B check_latency, ~ B latency(Y), 0 < X, ~B unrecoverable}<- assert_shared(latency(0)), print(SpeedReadinglatency0);

+precedingSpeed(X): {B check_latency, B latency(Y), X == 0, B next_latency(Y,Z)}<- remove_shared(latency(Y)), assert_shared(latency(Z)),  print(Z);
+precedingSpeed(X): {B check_latency, B latency(Y), X == 0, ~B next_latency(Y,Z)}<- remove_shared(latency(Y)), assert_shared(unrecoverable), print(unrecoverable);

+precedingSpeed(X): {B check_latency, B latency(Y), 0 < Y, 0 < X, ~B unrecoverable}<- remove_shared(latency(Y)), assert_shared(latency(0)), print(latency0);


+!breaking_platoon [perform]: {True}<- run(breaking_platoon);
+!adjust_distance_parameter(X) [perform]: {B spacing(X,Y)}<- run(pred(set_spacing),args(Y)), print(Y);