\documentclass[a4]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{../../manual/manual}
\include{mylistings}
\makeindex

\author{Louise A. Dennis}

\title{AIL Tutorial 3 -- Dynamic and Random Environments}

\begin{document}
\maketitle
This is the third in a series of tutorials on the use of the Agent Infrastructure Layer (\ail).  This tutorial covers creating environments for agent programs which contain dynamic or random behaviour.   Dynamic behaviour is behaviour that may occur without the agents doing anything to cause it.  Random behaviour is when the outcome of an action, the input to a sensor, or the dynamic behaviour of the environment has some element of chance to it.

It should be noted that the \eass\ language is intended for use with dynamic and random environments and has its own customised support for them.  If you are working with the \eass\ language you may wish to skip this tutorial and use the \eass\ tutorials on environments instead.

Files for this tutorial can be found in the \texttt{mcapl} distribution in the directory \texttt{src/examples/gwendolen/ail\_tutorials/tutorial3}.

The tutorial assumes a good working knowledge of Java programming and an understanding of the basics of construction \ail\ environments as discussion in \ail\ tutorial 2.

\section{Dynamic Environments}

A dynamic environment is one that gets to take action, specifically to effect the percepts available in the system, without any agent taking any particular action.  To do this the environment needs to be included in the scheduler that is used to decide which agent gets to act next.

The schedulers all expect to pick between objects that implement the \texttt{ajpf.MCAPLJobber} class so the first thing a dynamic environment needs to do is implement this interface.  This interface includes implementing a \texttt{do\_job()} which should contain the perception changes to be made when the environment runs.  Once this is done the environment needs to be added to the scheduler and set up to receive notifications from the scheduler.  Listing~\ref{code:RobotEnv} shows a simple dynamic environment for an agent that searches a grid in order to find a human.  The agent program searches a grid by performing \lstinline{move_to} actions and at some point the environment inserts the perception that the robot sees a human to rescue.
\begin{lstlisting}[float,caption=RobotEnv,basicstyle=\sffamily,language=Java,style=easslisting,label=code:RobotEnv]
public class RobotEnv extends DefaultEnvironment
                                       implements MCAPLJobber {
	
  public RobotEnv() {
    super();
    getScheduler().addJobber(this);
  }

  @Override
  public int compareTo(MCAPLJobber o) {
    return o.getName().compareTo(getName());
  }

  @Override
  public void do_job() {
    addPercept(new Predicate("human"));
  }

  @Override
  public String getName() {
    return "gwendolen.ail_tutorials.tutorial3.RobotEnv";
  }   

  @Override
  public Unifier executeAction(String agName, Action act) 
                                         throws AILexception {
    if (act.getFunctor().equals("move_to")) {
      Predicate robot_position = new Predicate("at");
      Predicate old_position = new Predicate("at");
      robot_position.addTerm(act.getTerm(0));
      robot_position.addTerm(act.getTerm(1));
      old_position.addTerm(new VarTerm("X"));
      old_position.addTerm(new VarTerm("Y"));
      removeUnifiesPercept(old_position);
      addPercept(robot_position);
    }
    return super.executeAction(agName, act);
  }
}
\end{lstlisting}
Line 2 shows that the class implements \texttt{MCAPLJobber}.  At line 6 the environment is added as a jobber to the scheduler.  Lines 9-23 show the three methods that need to be implemented for the \texttt{MCAPLJobber} interface.  Schedulers generally compare jobbers by their names to \texttt{compareTo} implements this while \texttt{getName()} returns a name for the jobber.  \texttt{do\_job()} implements adding the perception of a human.

Lastly \texttt{executeAction} implements the result of the robot moving by changing the perceptions of its coordinates.  This uses \texttt{removeUnifiesPercept} to remove the old position and then asserts the new one.

\subsection{A Note on Schedulers}

The default scheduler used by \texttt{DefaultEnvironment} is \texttt{ail.mas.ActionScheduler}.  This makes a random scheduling choice from among all its jobbers each time perceptions change in the environment.  In general this works well but can become a problem if one of the jobbers (either an agent or the environment) may get stuck in a run in which it never changes any perceptions -- e.g., an agent never takes an action or only does print actions (or similar) which don't alter perceptions -- in these situations that jobber can run indefinitely without the scheduler ever being prompted to make another choice.

There are other three other schedulers in the current distribution:

\begin{description}
\item[NActionScheduler] This functions as \texttt{ActionScheduler} except ever $n$ times it is invoked it forces a choice irrespective of whether perceptions have changed.  This can be particularly useful if the environment is connecting to an external system and its use is discussed in the \eass\ tutorials since the language is intended to work in this way.  It isn't advisable to use the \texttt{NActionScheduler} in verification since it contains counters that will increase the number of model-checking states.
\item[RoundRobinScheduler]  This scheduler acts like \texttt{ActionScheduler} except that instead of making a random choice between jobbers, it selects each in turn.
\item[SingleAgentScheduler] This is for situations when there is only one jobber and effectively just returns that one jobber each time it is called.
\end{description}

\section{Adding Randomness}

It is tempting to add random behaviour to an environment simply through use of \java's \texttt{Random} class.  However this will break the system's ability to record and replay runs through the program.  The simplest way to add some random behaviour to an environment is to subclass \texttt{ail.mas.DefaultEnvironmentwRandomness} rather than \texttt{ail.mas.DefaultEnvironment}.  This provides two \texttt{Choice} objects which are the way the \ail\ manages random behaviour.

The \texttt{random\_booleans} object has one method, \texttt{nextBoolean()} which will return either true or false.  The \texttt{random\_ints} ojbect has one method, \texttt{nextInt(int i)}, which will return a random integer between \texttt{0} and \texttt{i}.  Listing~\ref{code:RandomRobotEnv} shows a sample environment for the search and rescue robot.  This has a human at (1, 1) in the grid and the robot has a 50\% chance of spotting the human if it is in the same grid square.   If you run this program several times you will see that sometimes the robot finds the human quickly and sometimes it has to search the grid several times.

\begin{lstlisting}[float,caption=RandomRobotEnv,basicstyle=\sffamily,language=Java,style=easslisting,label=code:RandomRobotEnv]
public class RandomRobotEnv extends DefaultEnvironmentwRandomness {
  int human_x = 1;
  int human_y = 1;

  public Unifier executeAction(String agName, Action act) throws AILexception {
    if (act.getFunctor().equals("move_to")) {
      Predicate robot_position = new Predicate("at");
      Predicate old_position = new Predicate("at");
      robot_position.addTerm(act.getTerm(0));
      robot_position.addTerm(act.getTerm(1));
      old_position.addTerm(new VarTerm("X"));
      old_position.addTerm(new VarTerm("Y"));
      removeUnifiesPercept(old_position);
      addPercept(robot_position);
      if (((NumberTerm) act.getTerm(0)).solve() == human_x 
            && ((NumberTerm) act.getTerm(1)).solve() == human_y ) {
        if (random_booleans.nextBoolean()) {
          addPercept(new Predicate("human"));
        }
      }
    }
    return super.executeAction(agName, act);
  }
	      
}
\end{lstlisting}

In Listing~\ref{code:RandomRobotEnv} lines 17-19 add the percept, \lstinline{human} if \texttt{random\_booleans.nextBoolean()} returns true.

\subsection{Random Doubles}
The \ail\ doesn't have support for random doubles (in part because model checking requires a finite state space) but it does let you specify a probability distribution over a set of choices.  Do do this you need to create your own \texttt{Choice} object.  Say, for instance, in the above example the human is moving between the squares and could be at (0, 1), (1, 1) or (2, 1) with a 50\% chance of being at (1, 1), a 30\% chance of beineg at (2, 1) and a 20\% chance of being at (0, 1).

Listing~\ref{code:RandomRobotEnv2} shows an environment with this behaviour.  An integer \texttt{Choice} object, \texttt{human\_location} is declared as a field in line 4.  This is then instantiated by the \texttt{setMAS} method in lines 25-31.  This method overrides the implementation in \texttt{DefaultEnvironmentwRandomness} so first we call the super-method, then we create the \texttt{Choice} object and lastly we add the choices to it -- the humans x-coordinate is 1 with a probability of 0.5, 2 with a probability of 0.3 and 0 with a probability of 0.2.

In line 16 you can see the call to the objects \texttt{get\_choice()} method being invoked to return the correct integer.
\begin{lstlisting}[float,caption=RandomRobotEnv2,basicstyle=\sffamily,language=Java,style=easslisting,label=code:RandomRobotEnv2]
public class RandomRobotEnv2 extends DefaultEnvironmentwRandomness {
  int human_x = 1;
  int human_y = 1;
  Choice<Integer> human_location;

  public Unifier executeAction(String agName, Action act) throws AILexception {
    if (act.getFunctor().equals("move_to")) {
      Predicate robot_position = new Predicate("at");
      Predicate old_position = new Predicate("at");
      robot_position.addTerm(act.getTerm(0));
      robot_position.addTerm(act.getTerm(1));
      old_position.addTerm(new VarTerm("X"));
      old_position.addTerm(new VarTerm("Y"));
      removeUnifiesPercept(old_position);
      addPercept(robot_position);
      human_x = human_location.get_choice();
      if (((NumberTerm) act.getTerm(0)).solve() == human_x 
            && ((NumberTerm) act.getTerm(1)).solve() == human_y ) {
        addPercept(new Predicate("human"));
      }
    }
    return super.executeAction(agName, act);
  }

  public void setMAS(MAS m) {
    super.setMAS(m);
    human_location = new Choice<Integer>(m.getController());
    human_location.addChoice(0.5, 1);
    human_location.addChoice(0.3, 2);
    human_location.addChoice(0.2, 0);
  }
	      
}
\end{lstlisting}

\texttt{Choice} objects can be created to return any object -- integers, \texttt{Predicates}, \texttt{AILAgents} by being given the correct type and instantiated correctly.  It is important to remember that the probabilities of the choices added by the \texttt{addChoice} method should add up to 1.

If you genuinely need random doubles in an \ail\ environment then you can use \java's Random class but be aware that the record and replay functionality will no longer work.

\end{document}
