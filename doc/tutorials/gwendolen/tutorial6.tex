\documentclass[a4]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{../../manual/manual}
\include{mylistings}
\makeindex

\author{Louise A. Dennis}

\title{Gwendolen Tutorial 6 -- Finer Control: \\
Suspending and Locking Intentions, Dropping Goals}

\begin{document}
\maketitle
This is the sixth in a series of tutorials on the use of the \gwendolen\ programming language.  This tutorial covers finer control of intentions by suspending and locking them.  It also looks at how goals can be dropped.

Files for this tutorial can be found in the \texttt{mcapl} distribution in the directory \texttt{src/examples/gwendolen/tutorials/tutorial6}.

\section{Wait For: Suspending Intentions}

Recall the sample answer to the second exercise in tutorial 3 in which we had to introduce a ``do nothing'' action in order to delay the replanning of an achievement goal.  In the code in Listing~\ref{code:pickuprubble_waitfor} we use, instead some new syntax \lstinline{*checked(X, Y)} which means \emph{wait until $checked(X, Y)$ is true before continuing.}

\begin{lstlisting}[float,caption=Pick Up Rubble (Reasoning Rules),basicstyle=\sffamily,style=easslisting,language=Gwendolen,label=code:pickuprubble_waitfor]
GWENDOLEN

:name: robot

:Initial Beliefs:

square(1, 1) square(1, 2) square(1, 3) square(1, 4) square(1, 5)
square(2, 1) square(2, 2) square(2, 3) square(2, 4) square(2, 5)
square(3, 1) square(3, 2) square(3, 3) square(3, 4) square(3, 5)
square(4, 1) square(4, 2) square(4, 3) square(4, 4) square(4, 5)
square(5, 1) square(5, 2) square(5, 3) square(5, 4) square(5, 5)

:Reasoning Rules:

square_to_check(X, Y) :- square(X, Y), ~checked(X, Y);
no_rubble_in(X, Y) :- checked(X, Y), no_rubble(X, Y);
all_squares_checked :- ~square_to_check(X, Y), ~holding(rubble), at(2, 2);

:Initial Goals:

all_squares_checked [achieve]

:Plans:

+!all_squares_checked [achieve] : {B square_to_check(X, Y), ~B holding(rubble)} <- move_to(X, Y), *checked(X, Y);
+!all_squares_checked [achieve] : {B holding(rubble)} <- move_to(2, 2), drop;

+rubble(X, Y) : {~B at(2, 2)} <- lift_rubble, +checked(X, Y);

+at(X, Y) : {~B rubble(X, Y)} <- +checked(X, Y);
+at(2, 2) : {True} <- +checked(2, 2);
\end{lstlisting}
We have adapted the program so that after moving to the square (X, Y) the agent waits until it believes it has checked that square.  Then we delay the addition of that belief until after the agent as lifted rubble.

If you run this program with logging for \texttt{ail.semantics.AILAgent} you will see that the intention is marked as \texttt{SUSPENDED} when the wait for deed is encountered.
\begin{verbatim}
SUSPENDED
source(self):: 
   *  +!_aall_squares_checked()||True||+*...checked(1,1)()||[X-1, Y-1]
   *  start||True||+!_aall_squares_checked()()||[]
\end{verbatim}
Once an intention is suspended it can not become the current intention until it is unsuspended.  In the case of the wait for command this happens when the predicate that is waiting for is believed.  Below you can see how this happens when \texttt{checked(1, 1)} is added to the belief base.

\begin{verbatim}
ail.semantics.AILAgent[FINE|main|4:01:48]: robot
=============
After Stage StageC :
[at/2-at(1,1), , 
square/2-square(1,1), square(1,2), square(1,3), square(1,4), square(1,5), square(2,1), square(2,2), square(2,3), square(2,4), square(2,5), square(3,1), square(3,2), square(3,3), square(3,4), square(3,5), square(4,1), square(4,2), square(4,3), square(4,4), square(4,5), square(5,1), square(5,2), square(5,3), square(5,4), square(5,5), ]
[all_squares_checked/0-[_aall_squares_checked()]]
[]
source(self):: 
   *  +at(X0,Y0)||True||+checked(X0,Y0)()||[X-1, X0-1, Y-1, Y0-1]

[SUSPENDED
source(self):: 
   *  +!_aall_squares_checked()||True||+*...checked(1,1)()||[X-1, Y-1]
   *  start||True||+!_aall_squares_checked()()||[]
] 
ail.semantics.AILAgent[FINE|main|4:01:48]: Applying Handle Add Belief with Event 
ail.semantics.AILAgent[FINE|main|4:01:48]: robot
=============
After Stage StageD :
[at/2-at(1,1), , 
checked/2-checked(1,1), , 
square/2-square(1,1), square(1,2), square(1,3), square(1,4), square(1,5), square(2,1), square(2,2), square(2,3), square(2,4), square(2,5), square(3,1), square(3,2), square(3,3), square(3,4), square(3,5), square(4,1), square(4,2), square(4,3), square(4,4), square(4,5), square(5,1), square(5,2), square(5,3), square(5,4), square(5,5), ]
[all_squares_checked/0-[_aall_squares_checked()]]
[]
source(self):: 

[source(self):: 
   *  +!_aall_squares_checked()||True||+*...checked(1,1)()||[X-1, Y-1]
   *  start||True||+!_aall_squares_checked()()||[]
, source(self):: 
   *  +checked(1,1)||True||npy()||[]
] 
\end{verbatim}

The wait for command is particularly useful in simulated or physical environments where actions may take some time to complete.  It allows the agent to continue operating (e.g., performing error monitoring) while waiting until it recognises that an action has finished before continuing with what it was doing.




\end{document}
